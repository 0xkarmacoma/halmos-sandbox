// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";

import {SymTest} from "halmos-cheatcodes/SymTest.sol";

import {ERC20} from "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

import {OdosLimitOrderRouter} from "src/OdosLimitOrderRouter.sol";
import {UniversalSigValidator} from "src/OdosLimitOrderRouter.sol";


contract MockERC20 is ERC20 {
    constructor(uint256 initialSupply) ERC20("MockERC20", "MOCK") {
        _mint(msg.sender, initialSupply);
    }
}

contract Test116 is Test, SymTest {
    bytes32 private constant ERC6492_DETECTION_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;

    OdosLimitOrderRouter internal odosLimitOrderRouter;
    MockERC20 internal mockERC20;
    address owner;

    function setUp() public {
        owner = svm.createAddress("owner");

        // deploy the router
        vm.prank(owner);
        odosLimitOrderRouter = new OdosLimitOrderRouter();

        // deploy the mock token
        mockERC20 = new MockERC20(1 ether);

        // fund the router
        mockERC20.transfer(address(odosLimitOrderRouter), 1 ether);
    }

    function createUniversalSignature(bytes memory _signature) internal pure returns (bytes memory) {
        bool isCounterfactual = svm.createBool("isCounterfactual");

        if (isCounterfactual) {
            // pack symbolic ERC6492 data
            return abi.encodePacked(
                abi.encode(
                    svm.createAddress("create2Factory"),
                    svm.createBytes(1024, "factoryCalldata"),
                    svm.createBytes(65, "sigToValidate")
                ),
                ERC6492_DETECTION_SUFFIX
            );
        } else {
            return _signature;
        }
    }

    /// @dev checks that it's not possible for a passerby to
    function test_odosUniversalSigValidatorExploit(bytes memory _signature) external {
        uint256 initialBalance = mockERC20.balanceOf(address(odosLimitOrderRouter));

        // create an arbitrary unprivileged sender
        address sender = svm.createAddress("sender");
        vm.assume(sender != address(owner));

        // perform a call to the router
        vm.prank(sender);
        odosLimitOrderRouter.isValidSigImpl(
            svm.createAddress("signer"),
            svm.createBytes32("hash"),
            createUniversalSignature(_signature),
            svm.createBool("allowSideEffects")
        );

        // check that the balance of the router has not decreased
        uint256 finalBalance = mockERC20.balanceOf(address(odosLimitOrderRouter));
        assertGe(finalBalance, initialBalance);
    }
}



